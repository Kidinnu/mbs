%% ========================================================================
% Солнечная батарея МКА
% Метод построения уравнения движения систем тел со сферическими, 
% универсальными и цилиндрическими шарнирами Й. Виттенбурга
%
% Юдинцев В. В. 08.Apr.2020
% =========================================================================
clear all; clc; 
% Количество тел
p.n  = 4;

p.getForces  = @getForces;
p.getTorques = @getTorques;

% Колчиество степеней свободы в каждом шарнире (от 1 до 3)
p.na = [1; 1; 1; 1];

% Матрица инцидентности 
p.S0 = [1 0 0 0];
p.S  = [-1  1  1  1;
        +1 -1  0  0;
         0  0 +1  0;
         0  0  0 -1];

% Створка квадратная нулевой толщины. Сторона L 
L = 1;     
% Масса створки
m = 5;
     
% Шарнирные вектора
p.C  = zeros(3,p.n,p.n);

p.C(:,1,1)  = [-L/2;  0;    0];
p.C(:,1,2)  = [   0;  0; -L/2];
p.C(:,1,3)  = [   0;  0; +L/2];
p.C(:,1,4)  = [+L/2;  0;    0];
p.C(:,2,2)  = [-L/2;  0;    0];
p.C(:,3,3)  = [-L/2;  0;    0];
p.C(:,4,4)  = [-L/2;  0;    0];

% Масса тел
p.mass = [m;m;m;m];       

% Тензор инерции
p.I    = zeros(3,3,p.n);
p.I(:,:,1) = p.mass(1)*diag([0.01,0.01,0.01]);
p.I(:,:,2) = p.mass(2)*diag([0.01,0.01,0.01]);
p.I(:,:,3) = p.mass(3)*diag([0.01,0.01,0.01]);
p.I(:,:,4) = p.mass(4)*diag([0.01,0.01,0.01]);

% Кинематика
p.A  = cell(p.n,1);
p.p  = cell(p.n,1);
p.pw = cell(p.n,1);

% Матрицы поворота вокруг осей x, y, z
Ax = @(x) [1 0 0; 0 cos(x) -sin(x); 0 sin(x) cos(x)];
Ay = @(x) [cos(x) 0 sin(x); 0 1 0; - sin(x) 0 cos(x)];
Az = @(x) [cos(x) -sin(x) 0; sin(x) cos(x) 0; 0 0 1];

% Матрича преобразования координат из базиса C1x1y1z1  нулевой Ox0y0z0  
% Определяется одним углом phi1
% Стержень 1 вращается относительно Ox0y0z0  вокруг оси y0
p.A{1} = @(q) Az(q);

% Матрича преобразования координат из базиса C2x2y2z2 в С1x1y1z1
% Определяется одним углом phi2
% Стержень 2 вращается относительно стержная 1 вокруг оси y1
p.A{2} = @(q) Az(q);

p.A{3} = @(q) Az(q);
p.A{4} = @(q) Az(q);

% p-вектор
% Координаты единичного вектора p11 вокруг которого происходит вращение стержня
% 1 относительно неподвижной системы координат. Координаты вектора
% записываются в системе координат первого стержня
p.p{1} = @(q) [0;0;1];
% Координаты единичного вектора p21 вокруг которого происходит врещение стержня
% 2 относительно стержня 1. Координаты едичинного вектора
% записываются в системе координат второго стержня
p.p{2} = @(q) [0;0;1];
p.p{3} = @(q) [0;0;1];
p.p{4} = @(q) [0;0;1];

% Относительная угловая скорость
% Произведение единичного вектора p11 на обобщенну скорость phi1'
p.Wr{1} = @(q,dq)  p.p{1}(q)*dq;
% Произведение единичного вектора p21 на обобщенну скорость phi2'
p.Wr{2} = @(q,dq)  p.p{2}(q)*dq;
p.Wr{3} = @(q,dq)  p.p{3}(q)*dq;
p.Wr{4} = @(q,dq)  p.p{4}(q)*dq;

% Т.к. координаты единичных векторов постоянные числа, 
% их производные равны нулю  
p.pw{1} = @(q,dq) [0;0;0];
p.pw{2} = @(q,dq) [0;0;0]; 
p.pw{3} = @(q,dq) [0;0;0]; 
p.pw{4} = @(q,dq) [0;0;0]; 

% Препроцессинг (предварительная обработка)
preproc;

% Начальные условия
q0 = [pi/2; 0.8;   0.0; 0.0];

% Интегрирование
[t, q] = ode113(@(t,q) ode_dqdt(t,q,p), 0:0.05:10, q0, odeset('RelTol',1e-6));
fprintf('OK\n');

%% Результаты
set(0,'defaultLineLineWidth',2);
set(0,'defaultFigureColor','w');
set(0,'defaultAxesFontSize',12);
set(0,'DefaultAxesXGrid','on');
set(0,'DefaultAxesYGrid','on');

figure;
plot(t, q(:,1));
hold on;
plot(t, q(:,2));
xlabel('t, s');
legend('\phi_{1}','\phi_{2}');
hold off;
set(gca,'FontSize',12); grid on;

%% Валидация: Проверка сохранения энергии
[T, V] = Energy(q,p);
figure;
plot(t, T+V,'-',t, T,'--', t, V,':'); 
legend('Полная энергия', 'Кинетическая энергия', 'Потенциальная энергия'); 
xlabel('t, с'); ylabel('Энергия, Дж');

%% Анимация
figure('Position',[100 100 800 400]);
axis([-2*L 2*L -2*L 0]);
set(gca,'FontSize',20);
grid on; hold on;
daspect([1 1 1]);
for i=1:size(t,1)
    cla;
    plot([0,-L*sin(q(i,1)),-L*sin(q(i,1))-L*sin(q(i,1)+q(i,2))],[0,-L*cos(q(i,1)),-L*cos(q(i,1))-L*cos(q(i,1)+q(i,2))],'o-','LineWidth',4,'MarkerSize',10);    
    getframe;
end


%%
function F = getForces(t,q,p)
    % in 0 frame
    F = zeros(3,p.n);
    for i=1:p.n
        F(:,i) = [0;0;-p.mass(i)*9.807]; 
    end
end

function M = getTorques(t,q,p)
    % in body frame
    M = zeros(3,p.n);
end
